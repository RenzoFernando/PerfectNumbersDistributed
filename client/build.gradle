// PerfectNumbersDistributed/client/build.gradle
plugins {
    id 'java' // Plugin para compilar código Java
    id 'application' // Plugin para ejecutar la aplicación desde Gradle
    // Añadir el plugin de JavaFX para gestionar dependencias y tareas de JavaFX
    id 'org.openjfx.javafxplugin' version '0.1.0' // O la versión más reciente compatible
}

application {
    // Clase principal que contiene el método main() para lanzar la aplicación JavaFX
    mainClass = 'com.example.client.ClientAppLauncher'
}

// Configuración específica para JavaFX
javafx {
    version = "17" // Especifica la versión de JavaFX a utilizar (debe ser compatible con tu JDK)
    modules = [ 'javafx.controls', 'javafx.fxml' ] // Módulos de JavaFX necesarios para la UI
}

dependencies {
    // Dependencia al subproyecto local 'PerfectNumbersApp' que contiene las clases generadas por ICE
    implementation project(':PerfectNumbersApp')

    // Declarar explícitamente la dependencia de ZeroC Ice.
    // Aunque se hereda del build.gradle raíz, añadirla aquí puede ayudar a resolver problemas de
    // visibilidad del classpath para el compilador en este módulo específico,
    // especialmente para métodos heredados de ObjectPrx como ice_toString().
    implementation 'com.zeroc:ice:3.7.10'

    // Las dependencias específicas de los módulos de JavaFX (javafx.controls, javafx.fxml)
    // son gestionadas automáticamente por el plugin 'org.openjfx.javafxplugin'.
}

jar {
    // Configuración para el archivo JAR generado (opcional para ejecución con Gradle)
    manifest {
        attributes(
                // Especifica la clase principal en el manifiesto del JAR para hacerlo ejecutable.
                'Main-Class': application.mainClass.get()
        )
    }
    // Crear un "fat JAR" (un JAR que incluye todas sus dependencias) es más complejo
    // con JavaFX debido a los componentes nativos. La forma más simple de ejecutar
    // durante el desarrollo es usando la tarea 'run' de Gradle: ./gradlew :client:run
    // Para una distribución, se podrían usar herramientas como jpackage o plugins de Gradle
    // más especializados como 'badass-jlink-plugin'.
    /*
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    */
}